"""
Database access layer for onshape_part_manager.

Provides MongoDB integration for Part, Assembly, Subsystem, and Project datatypes.
Includes part number generation and project management functionality.

Part Numbering System:
- 172 projects: 172-{project_code}-P{SS###} for parts, 172-{project_code}-A{SS###} for assemblies
  Where project_code = project identifier like "24A", "25B", "25C" for competition/offseason projects
  SS = subsystem number (00-99, where 00=full-robot, 99=miscellaneous)
  ### = sequential part/assembly number (000-999)

- NFR projects: NFR-SSSS-P{####} for parts, NFR-SSSS-A{####} for assemblies
  Where SSSS = subsystem number (0000-9999, where 0000=full-robot, 9999=miscellaneous)
  #### = sequential part/assembly number (0000-9999)

Auto-generation:
- MongoDB ObjectIds are automatically generated for all documents
- Subsystem numbers are auto-generated by finding the first available number
- Part numbers are auto-generated by finding the first available number in sequence
"""

from typing import List, Optional, Union, Any
import pymongo
from pymongo import MongoClient
from pymongo.collection import Collection
from pymongo.database import Database
from bson import ObjectId
from dataclasses import asdict, fields
import os
from datetime import datetime

from datatypes import Part, Assembly, Subsystem, Project


class DatabaseManager:
    """Manages MongoDB connection and provides CRUD operations for all datatypes."""
    
    def __init__(self, connection_string: str = "mongodb://localhost:27017/", 
                 database_name: str = "onshape_part_manager"):
        """
        Initialize database connection.
        
        Args:
            connection_string: MongoDB connection string
            database_name: Name of the database to use
        """
        self.client: MongoClient = MongoClient(connection_string)
        self.db: Database = self.client[database_name]
        
        # Collections for each datatype
        self.parts: Collection = self.db.parts
        self.assemblies: Collection = self.db.assemblies
        self.subsystems: Collection = self.db.subsystems
        self.projects: Collection = self.db.projects
    
    def generate_subsystem_number(self, project_identifier: str, project_code: str = None) -> int:
        """
        Generate the next available subsystem number for a project.
        
        Args:
            project_identifier: Either '172' or 'nfr'
            project_code: Project code for 172 projects (e.g., "24A"), None for NFR
            
        Returns:
            Next available subsystem number
            
        Raises:
            ValueError: If parameters are invalid
        """
        if project_identifier not in ['172', 'nfr']:
            raise ValueError("project_identifier must be either '172' or 'nfr'")
        
        # Determine the range based on project type
        if project_identifier == '172':
            max_subsystem = 99  # 00-99 for 172 projects
            # Find existing subsystems for this specific 172 project
            project = self.get_172_project_by_code(project_code) if project_code else None
        else:  # nfr
            max_subsystem = 9999  # 0000-9999 for NFR projects
            # Find existing subsystems for the NFR project
            project = self.get_nfr_project()
        
        existing_numbers = set()
        
        if project:
            # Get existing subsystem numbers from this project
            for subsystem in project.subsystems:
                existing_numbers.add(subsystem.subsystem_number)
        
        # Find the first available number
        for i in range(max_subsystem + 1):
            if i not in existing_numbers:
                return i
        
        raise RuntimeError(f"No available subsystem numbers in range 0-{max_subsystem}")
    
    def _document_to_object(self, doc: dict, obj_type: type) -> Any:
        """
        Convert a MongoDB document to a dataclass object.
        
        Args:
            doc: MongoDB document dictionary
            obj_type: Target dataclass type
            
        Returns:
            Instance of obj_type
        """
        if not doc:
            return None
            
        # Remove MongoDB's _id field since our dataclasses don't have it
        doc_copy = doc.copy()
        if '_id' in doc_copy:
            del doc_copy['_id']
        
        # Handle nested objects for complex types
        if obj_type == Subsystem:
            # Convert nested parts and assemblies back to objects
            parts = [Part(**part_dict) for part_dict in doc_copy.get('parts', [])]
            assemblies = [Assembly(**assembly_dict) for assembly_dict in doc_copy.get('assemblies', [])]
            
            doc_copy['parts'] = parts
            doc_copy['assemblies'] = assemblies
            
        elif obj_type == Project:
            # Convert nested subsystems back to objects
            subsystems = []
            for subsystem_dict in doc_copy.get('subsystems', []):
                parts = [Part(**part_dict) for part_dict in subsystem_dict.get('parts', [])]
                assemblies = [Assembly(**assembly_dict) for assembly_dict in subsystem_dict.get('assemblies', [])]
                
                subsystem_dict['parts'] = parts
                subsystem_dict['assemblies'] = assemblies
                subsystems.append(Subsystem(**subsystem_dict))
            
            doc_copy['subsystems'] = subsystems
        
        return obj_type(**doc_copy)
        

    
    def generate_part_number(self, project_type: str, project_identifier: str, subsystem: int, 
                           item_type: str) -> str:
        """
        Generate a unique part number based on the new numbering system.
        
        For robot-specific parts (various competition/offseason projects):
        - Parts: 172-{project_code}-P{SS###} 
        - Assemblies: 172-{project_code}-A{SS###}
        Where project_code=project identifier (e.g., "24A", "25B", "25C"), SS=subsystem (01-98, 00=full-robot, 99=misc), ###=part number (000-999)
        
        For non-specific parts (multi-year, single NFR project):
        - Parts: NFR-SSSS-P{####}
        - Assemblies: NFR-SSSS-A{####}
        Where SSSS=subsystem number (0000-9999), ####=part number (0000-9999)
        
        Args:
            project_type: Either '172' or 'nfr'
            project_identifier: Project code for 172 projects (e.g., "24A", "25B", "25C") or "nfr" for NFR projects
            subsystem: Subsystem number (0-99 for 172, 0-9999 for nfr, where 0=full-robot, 99/9999=misc)
            item_type: Either 'part' or 'assembly'
            
        Returns:
            Generated part number string
            
        Raises:
            ValueError: If parameters are invalid
        """
        if project_type not in ['172', 'nfr']:
            raise ValueError("project_type must be either '172' or 'nfr'")
        
        if item_type not in ['part', 'assembly']:
            raise ValueError("item_type must be either 'part' or 'assembly'")
        
        if project_type == '172':
            # Validate project_identifier format for 172 projects (should be like "24A", "25B", etc.)
            if not project_identifier or len(project_identifier) < 3:
                raise ValueError("project_identifier for 172 projects must be in format like '24A', '25B', '25C'")
            
        # Validate subsystem range based on project type
        if project_type == '172':
            if subsystem < 0 or subsystem > 99:
                raise ValueError("subsystem must be between 0 and 99 for 172 projects")
        else:  # nfr
            if subsystem < 0 or subsystem > 9999:
                raise ValueError("subsystem must be between 0 and 9999 for NFR projects")
        
        item_prefix = 'P' if item_type == 'part' else 'A'
        
        if project_type == '172':
            # Format: 172-{project_code}-P{SS###} or 172-{project_code}-A{SS###}
            prefix = f"172-{project_identifier}-{item_prefix}{subsystem:02d}"
            
            # Find existing part numbers with this prefix
            collection = self.parts if item_type == 'part' else self.assemblies
            existing_numbers = set()
            
            # Search for parts/assemblies with names starting with this prefix
            for doc in collection.find({"name": {"$regex": f"^{prefix}"}}):
                name = doc.get("name", "")
                if name.startswith(prefix) and len(name) >= len(prefix) + 3:
                    try:
                        number = int(name[len(prefix):len(prefix)+3])
                        existing_numbers.add(number)
                    except ValueError:
                        continue
            
            # Find the first available number (0-999)
            for i in range(1000):
                if i not in existing_numbers:
                    return f"{prefix}{i:03d}"
            
            raise RuntimeError("No available part numbers in range 000-999")
        
        else:  # nfr
            # Format: NFR-SSSS-P{####} or NFR-SSSS-A{####}
            prefix = f"NFR-{subsystem:04d}-{item_prefix}"
            
            # Find existing part numbers with this prefix
            collection = self.parts if item_type == 'part' else self.assemblies
            existing_numbers = set()
            
            # Search for parts/assemblies with names starting with this prefix
            for doc in collection.find({"name": {"$regex": f"^{prefix}"}}):
                name = doc.get("name", "")
                if name.startswith(prefix) and len(name) >= len(prefix) + 4:
                    try:
                        number = int(name[len(prefix):len(prefix)+4])
                        existing_numbers.add(number)
                    except ValueError:
                        continue
            
            # Find the first available number (0-9999)
            for i in range(10000):
                if i not in existing_numbers:
                    return f"{prefix}{i:04d}"
            
            raise RuntimeError("No available part numbers in range 0000-9999")
    
    def create_subsystem_with_auto_number(self, name: str, project_identifier: str, 
                                        project_code: str = None, parts: List[Part] = None, 
                                        assemblies: List[Assembly] = None) -> tuple[Subsystem, ObjectId]:
        """
        Create a subsystem with auto-generated subsystem number.
        
        Args:
            name: Name of the subsystem
            project_identifier: Either '172' or 'nfr'
            project_code: Project code for 172 projects (e.g., "24A"), None for NFR
            parts: List of parts in the subsystem (default: empty list)
            assemblies: List of assemblies in the subsystem (default: empty list)
            
        Returns:
            Tuple of (created Subsystem object, ObjectId)
        """
        if parts is None:
            parts = []
        if assemblies is None:
            assemblies = []
            
        # Generate auto subsystem number
        subsystem_number = self.generate_subsystem_number(project_identifier, project_code)
        
        # Create subsystem
        subsystem = Subsystem(
            name=name,
            subsystem_number=subsystem_number,
            parts=parts,
            assemblies=assemblies
        )
        
        object_id = self.create_subsystem(subsystem)
        return subsystem, object_id
    
    def close(self):
        """Close the database connection."""
        self.client.close()
    
    # Part CRUD operations
    def create_part(self, part: Part) -> ObjectId:
        """
        Create a new part in the database.
        
        Args:
            part: Part object to create
            
        Returns:
            ObjectId of the created part
        """
        part_dict = asdict(part)
        result = self.parts.insert_one(part_dict)
        return result.inserted_id
    
    def get_part(self, part_id: ObjectId) -> Optional[Part]:
        """
        Retrieve a part by its ObjectId.
        
        Args:
            part_id: MongoDB ObjectId of the part
            
        Returns:
            Part object if found, None otherwise
        """
        part_dict = self.parts.find_one({"_id": part_id})
        return self._document_to_object(part_dict, Part)
    
    def update_part(self, part_id: ObjectId, part: Part) -> bool:
        """
        Update an existing part in the database.
        
        Args:
            part_id: MongoDB ObjectId of the part to update
            part: Updated Part object
            
        Returns:
            True if part was updated, False otherwise
        """
        part_dict = asdict(part)
        result = self.parts.replace_one({"_id": part_id}, part_dict)
        return result.modified_count > 0
    
    def delete_part(self, part_id: ObjectId) -> bool:
        """
        Delete a part from the database.
        
        Args:
            part_id: MongoDB ObjectId of the part to delete
            
        Returns:
            True if part was deleted, False otherwise
        """
        result = self.parts.delete_one({"_id": part_id})
        return result.deleted_count > 0
    
    def list_parts(self, limit: int = 100) -> List[Part]:
        """
        List all parts with optional limit.
        
        Args:
            limit: Maximum number of parts to return
            
        Returns:
            List of Part objects
        """
        parts = []
        for part_dict in self.parts.find().limit(limit):
            parts.append(self._document_to_object(part_dict, Part))
        return parts
    
    # Assembly CRUD operations
    def create_assembly(self, assembly: Assembly) -> ObjectId:
        """
        Create a new assembly in the database.
        
        Args:
            assembly: Assembly object to create
            
        Returns:
            ObjectId of the created assembly
        """
        assembly_dict = asdict(assembly)
        result = self.assemblies.insert_one(assembly_dict)
        return result.inserted_id
    
    def get_assembly(self, assembly_id: ObjectId) -> Optional[Assembly]:
        """
        Retrieve an assembly by its ObjectId.
        
        Args:
            assembly_id: MongoDB ObjectId of the assembly
            
        Returns:
            Assembly object if found, None otherwise
        """
        assembly_dict = self.assemblies.find_one({"_id": assembly_id})
        return self._document_to_object(assembly_dict, Assembly)
    
    def update_assembly(self, assembly_id: ObjectId, assembly: Assembly) -> bool:
        """
        Update an existing assembly in the database.
        
        Args:
            assembly_id: MongoDB ObjectId of the assembly to update
            assembly: Updated Assembly object
            
        Returns:
            True if assembly was updated, False otherwise
        """
        assembly_dict = asdict(assembly)
        result = self.assemblies.replace_one({"_id": assembly_id}, assembly_dict)
        return result.modified_count > 0
    
    def delete_assembly(self, assembly_id: ObjectId) -> bool:
        """
        Delete an assembly from the database.
        
        Args:
            assembly_id: MongoDB ObjectId of the assembly to delete
            
        Returns:
            True if assembly was deleted, False otherwise
        """
        result = self.assemblies.delete_one({"_id": assembly_id})
        return result.deleted_count > 0
    
    def list_assemblies(self, limit: int = 100) -> List[Assembly]:
        """
        List all assemblies with optional limit.
        
        Args:
            limit: Maximum number of assemblies to return
            
        Returns:
            List of Assembly objects
        """
        assemblies = []
        for assembly_dict in self.assemblies.find().limit(limit):
            assemblies.append(self._document_to_object(assembly_dict, Assembly))
        return assemblies
    
    # Subsystem CRUD operations
    def create_subsystem(self, subsystem: Subsystem) -> ObjectId:
        """
        Create a new subsystem in the database.
        
        Args:
            subsystem: Subsystem object to create
            
        Returns:
            ObjectId of the created subsystem
        """
        subsystem_dict = asdict(subsystem)
        result = self.subsystems.insert_one(subsystem_dict)
        return result.inserted_id
    
    def get_subsystem(self, subsystem_id: ObjectId) -> Optional[Subsystem]:
        """
        Retrieve a subsystem by its ObjectId.
        
        Args:
            subsystem_id: MongoDB ObjectId of the subsystem
            
        Returns:
            Subsystem object if found, None otherwise
        """
        subsystem_dict = self.subsystems.find_one({"_id": subsystem_id})
        return self._document_to_object(subsystem_dict, Subsystem)
    
    def update_subsystem(self, subsystem_id: ObjectId, subsystem: Subsystem) -> bool:
        """
        Update an existing subsystem in the database.
        
        Args:
            subsystem_id: MongoDB ObjectId of the subsystem to update
            subsystem: Updated Subsystem object
            
        Returns:
            True if subsystem was updated, False otherwise
        """
        subsystem_dict = asdict(subsystem)
        result = self.subsystems.replace_one({"_id": subsystem_id}, subsystem_dict)
        return result.modified_count > 0
    
    def delete_subsystem(self, subsystem_id: ObjectId) -> bool:
        """
        Delete a subsystem from the database.
        
        Args:
            subsystem_id: MongoDB ObjectId of the subsystem to delete
            
        Returns:
            True if subsystem was deleted, False otherwise
        """
        result = self.subsystems.delete_one({"_id": subsystem_id})
        return result.deleted_count > 0
    
    def list_subsystems(self, limit: int = 100) -> List[Subsystem]:
        """
        List all subsystems with optional limit.
        
        Args:
            limit: Maximum number of subsystems to return
            
        Returns:
            List of Subsystem objects
        """
        subsystems = []
        for subsystem_dict in self.subsystems.find().limit(limit):
            subsystems.append(self._document_to_object(subsystem_dict, Subsystem))
        return subsystems
    
    # Project CRUD operations
    def create_project(self, project: Project) -> ObjectId:
        """
        Create a new project in the database.
        
        Args:
            project: Project object to create
            
        Returns:
            ObjectId of the created project
        """
        project_dict = asdict(project)
        result = self.projects.insert_one(project_dict)
        return result.inserted_id
    
    def get_project(self, project_id: ObjectId) -> Optional[Project]:
        """
        Retrieve a project by its ObjectId.
        
        Args:
            project_id: MongoDB ObjectId of the project
            
        Returns:
            Project object if found, None otherwise
        """
        project_dict = self.projects.find_one({"_id": project_id})
        return self._document_to_object(project_dict, Project)
    
    def update_project(self, project_id: ObjectId, project: Project) -> bool:
        """
        Update an existing project in the database.
        
        Args:
            project_id: MongoDB ObjectId of the project to update
            project: Updated Project object
            
        Returns:
            True if project was updated, False otherwise
        """
        project_dict = asdict(project)
        result = self.projects.replace_one({"_id": project_id}, project_dict)
        return result.modified_count > 0
    
    def delete_project(self, project_id: ObjectId) -> bool:
        """
        Delete a project from the database.
        
        Args:
            project_id: MongoDB ObjectId of the project to delete
            
        Returns:
            True if project was deleted, False otherwise
        """
        result = self.projects.delete_one({"_id": project_id})
        return result.deleted_count > 0
    
    def list_projects(self, limit: int = 100) -> List[Project]:
        """
        List all projects with optional limit.
        
        Args:
            limit: Maximum number of projects to return
            
        Returns:
            List of Project objects
        """
        projects = []
        for project_dict in self.projects.find().limit(limit):
            projects.append(self._document_to_object(project_dict, Project))
        return projects
    
    def get_172_projects(self) -> List[Project]:
        """Get all projects with identifier '172'."""
        projects = []
        for project_dict in self.projects.find({"identifier": "172"}):
            projects.append(self._document_to_object(project_dict, Project))
        return projects
    
    def get_172_project_by_code(self, project_code: str) -> Optional[Project]:
        """Get a specific 172 project by its project code (e.g., '24A', '25B')."""
        project_dict = self.projects.find_one({"identifier": "172", "project_code": project_code})
        return self._document_to_object(project_dict, Project)
    
    def get_nfr_project(self) -> Optional[Project]:
        """Get the NFR project (there should be only one)."""
        project_dict = self.projects.find_one({"identifier": "nfr"})
        return self._document_to_object(project_dict, Project)
    
    def print_summary(self, detailed: bool = False):
        """
        Print a comprehensive summary of the database contents.
        
        Args:
            detailed: If True, includes individual part and assembly names
        """
        print("=" * 60)
        print("DATABASE SUMMARY")
        print("=" * 60)
        
        # Get total counts
        total_parts = self.parts.count_documents({})
        total_assemblies = self.assemblies.count_documents({})
        total_subsystems = self.subsystems.count_documents({})
        total_projects = self.projects.count_documents({})
        
        print(f"\nTOTAL COUNTS:")
        print(f"  Parts: {total_parts}")
        print(f"  Assemblies: {total_assemblies}")
        print(f"  Subsystems: {total_subsystems}")
        print(f"  Projects: {total_projects}")
        
        # Get all projects
        projects = self.list_projects()
        
        if not projects:
            print("\nNo projects found in database.")
            return
        
        print(f"\nPROJECTS:")
        print("-" * 40)
        
        # Group projects by type
        team_172_projects = [p for p in projects if p.identifier == "172"]
        nfr_projects = [p for p in projects if p.identifier == "nfr"]
        
        # Show 172 projects
        if team_172_projects:
            print(f"\n172 TEAM PROJECTS ({len(team_172_projects)}):")
            for project in sorted(team_172_projects, key=lambda x: x.project_code or ""):
                print(f"  {project.project_code} - {project.name}")
                print(f"    Year: {project.year}")
                print(f"    Description: {project.description}")
                print(f"    Subsystems: {len(project.subsystems)}")
                
                if project.subsystems:
                    total_project_parts = 0
                    total_project_assemblies = 0
                    
                    for subsystem in project.subsystems:
                        parts_count = len(subsystem.parts)
                        assemblies_count = len(subsystem.assemblies)
                        total_project_parts += parts_count
                        total_project_assemblies += assemblies_count
                        
                        print(f"      {subsystem.name} (#{subsystem.subsystem_number:02d}): {parts_count} parts, {assemblies_count} assemblies")
                        
                        if detailed and (parts_count > 0 or assemblies_count > 0):
                            if parts_count > 0:
                                print(f"        Parts: {', '.join([p.name for p in subsystem.parts])}")
                            if assemblies_count > 0:
                                print(f"        Assemblies: {', '.join([a.name for a in subsystem.assemblies])}")
                    
                    print(f"    Total: {total_project_parts} parts, {total_project_assemblies} assemblies")
                print()
        
        # Show NFR projects
        if nfr_projects:
            print(f"\nNFR PROJECTS ({len(nfr_projects)}):")
            for project in nfr_projects:
                print(f"  {project.name}")
                print(f"    Year: {project.year}")
                print(f"    Description: {project.description}")
                print(f"    Subsystems: {len(project.subsystems)}")
                
                if project.subsystems:
                    total_project_parts = 0
                    total_project_assemblies = 0
                    
                    for subsystem in project.subsystems:
                        parts_count = len(subsystem.parts)
                        assemblies_count = len(subsystem.assemblies)
                        total_project_parts += parts_count
                        total_project_assemblies += assemblies_count
                        
                        print(f"      {subsystem.name} (#{subsystem.subsystem_number:04d}): {parts_count} parts, {assemblies_count} assemblies")
                        
                        if detailed and (parts_count > 0 or assemblies_count > 0):
                            if parts_count > 0:
                                print(f"        Parts: {', '.join([p.name for p in subsystem.parts])}")
                            if assemblies_count > 0:
                                print(f"        Assemblies: {', '.join([a.name for a in subsystem.assemblies])}")
                    
                    print(f"    Total: {total_project_parts} parts, {total_project_assemblies} assemblies")
                print()
        
        # Show part numbering format information
        print("PART NUMBERING FORMATS:")
        print("-" * 40)
        print("172 Projects (Competition/Offseason):")
        print("  Parts:      172-{project_code}-P{SS###}")
        print("  Assemblies: 172-{project_code}-A{SS###}")
        print("  Where: project_code = '24A', '25B', '25C', etc.")
        print("         SS = subsystem number (00-99, 00=full-robot, 99=misc)")
        print("         ### = part/assembly number (000-999)")
        print()
        print("NFR Projects (Multi-year components):")
        print("  Parts:      NFR-SSSS-P{####}")
        print("  Assemblies: NFR-SSSS-A{####}")
        print("  Where: SSSS = subsystem number (0000-9999, 0000=full-robot, 9999=misc)")
        print("         #### = part/assembly number (0000-9999)")
        
        print("=" * 60)


def get_database_manager() -> DatabaseManager:
    """
    Factory function to get a DatabaseManager instance.
    
    Uses environment variables for configuration:
    - MONGODB_CONNECTION_STRING: MongoDB connection string (default: mongodb://localhost:27017/)
    - MONGODB_DATABASE_NAME: Database name (default: onshape_part_manager)
    """
    connection_string = os.getenv("MONGODB_CONNECTION_STRING", "mongodb://localhost:27017/")
    database_name = os.getenv("MONGODB_DATABASE_NAME", "onshape_part_manager")
    
    return DatabaseManager(connection_string, database_name)